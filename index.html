<html>

<head>
<title>bad-attitude</title>
<style>

body {
  font-size: 11pt;
  font-family: Lucida Sans Typewriter,Lucida Console,monaco,Bitstream Vera Sans Mono,monospace;
  background-color: #111;
  color: #aaa;
}

h1 {
  font-size: 12pt;
  text-align: center;
}

#container {
  max-width: 800px;
  width: 80%;
  margin: 0 auto;
  padding: 1ex;
}
#container td > * {
  width: 100%;
  margin: 0;
  padding: 1ex;
}

input {
  font-family: Lucida Sans Typewriter,Lucida Console,monaco,Bitstream Vera Sans Mono,monospace;
  background-color: #111;
  color: #eee;
  border: 1px solid #888;
}

#box {
  height: 10em;
  overflow: scroll;
}

</style>
<script>
// Redirect to HTTPS if we need to
(function() {
  if (window.location.href.match("http:")) {
    window.location.href = window.location.href.replace("http:", "https:");
  }
})();
</script>
</head>

<body>

<!-- "Fork me on Github" banner -->
<a href="https://github.com/bad-attitude/bad-attitude.github.io/"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/121cd7cbdc3e4855075ea8b558508b91ac463ac2/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png"></a>

<h1>bad-attitude</h1>
<table id=container>
<col width=80px/><col/>
<tr><td colspan=2><div id=box></div></td></tr>
<tr>
<td><input id="nick" placeholder="your-nick-here" /></td>
<td><input id="message" placeholder="your-chat-here" /></td>
</tr>
</table>


<script src=https://cdn.pubnub.com/pubnub.min.js></script>
<script>
//<![CDATA[

(function(){
var box = PUBNUB.$('box');
var nick = PUBNUB.$('nick');
var message = PUBNUB.$('message');
var channel = 'bad-attitude';

function clean(text) {
  var i = 0, m;
  text = text.replace(/&/g, '&amp;').replace(/</g, '&gt;');
  while((m = /\b(https?:\/\/\S+)/.exec(text.substring(i)))) {
    var ins = '<a href="' + encodeURI(m[1]) + '">' + m[1] + '</a>';
    text = text.substring(0, i + m.index) + ins +
      text.substring(i + m.index + m[1].length);
    i += m.index + ins.length;
  }
  return text;
}

// Generate the key from the URL fragment
// XXX: This might mean that the key won't be ready if we need it,
// but that seems unlikely, and we can detect it.
var CRYPTO = window.crypto.subtle;
var ALGO_HMAC = {name: "HMAC", hash: "SHA-256"};
var ALGO_KEY = "AES-GCM";
var ALGO_ENCRYPT = {
  name: "AES-GCM",
  tagLength: 128,
  iv: new Uint8Array(12)
};
var key = (function() {
  var fragment = window.location.hash.replace(/^#/, "");
  console.log("fragment: " + fragment);

  var fragmentData = new Uint8Array(fragment.length);
  for (var i=0; i<fragmentData.length; ++i) {
    fragmentData[i] = fragment.charCodeAt(i);
  }
  console.log("fragmentData: ");
  console.log(fragmentData);

  var zeros = new Uint8Array(32);
  for (var i=0; i<zeros.length; ++i) {
    zeros[i] = 0;
  }

  // HKDF(frag) = HMAC(HMAC(0, frag), 0x01)
  return CRYPTO.importKey("raw", zeros, ALGO_HMAC, false, ["sign"])
    .then(function(zeroKey) {
      return CRYPTO.sign(ALGO_HMAC, zeroKey, fragmentData);
    })
    .then(function(macData) {
      return CRYPTO.importKey("raw", macData, ALGO_HMAC, false, ["sign"]);
    })
    .then(function(macKey) {
      return CRYPTO.sign(ALGO_HMAC, macKey, new Uint8Array([0x01]));
    })
    .then(function(keyData) {
      return CRYPTO.importKey("raw", keyData, ALGO_KEY, false, ["encrypt", "decrypt"]);
    })
})();

// Returns nonce || ciphertext
function encrypt(str) {
  var plaintext = new Uint16Array(str.length);
  for (var i=0; i<str.length; ++i) {
    plaintext[i] = str.charCodeAt(i);
  }

  window.crypto.getRandomValues(ALGO_ENCRYPT.iv);
  return key.then(function(cryptoKey) {
      return CRYPTO.encrypt(ALGO_ENCRYPT, cryptoKey, plaintext)
    })
    .then(function(ciphertext) {
      var output = new Uint8Array(ALGO_ENCRYPT.iv.length + ciphertext.byteLength);
      output.set(ALGO_ENCRYPT.iv, 0);
      output.set(new Uint8Array(ciphertext), ALGO_ENCRYPT.iv.length);
      return window.btoa(String.fromCharCode.apply(null, output));
    });
}

function decrypt(base64) {
  var byteString = atob(base64);
  var nonceAndCiphertext = new Uint8Array(byteString.length);
  for (var i=0; i<byteString.length; ++i) {
    nonceAndCiphertext[i] = byteString.charCodeAt(i);
  }
  var ciphertext = nonceAndCiphertext.subarray(ALGO_ENCRYPT.iv.length);

  ALGO_ENCRYPT.iv.set(nonceAndCiphertext.subarray(0, ALGO_ENCRYPT.iv.length));
  return key.then(function(cryptoKey) {
      return CRYPTO.decrypt(ALGO_ENCRYPT, cryptoKey, ciphertext)
    })
    .then(function(plaintext) {
      var plaintextBuffer = new Uint16Array(plaintext);
      var plaintextString = "";
      for (var i=0; i<plaintextBuffer.length; ++i) {
        plaintextString += String.fromCharCode(plaintextBuffer[i]);
      }
      return plaintextString
    });
}

function defaultDisplay(obj) {
  return obj.nick + ': ' + obj.message;
}

// Adapted from https://airhorner.com/scripts/main.min.js
var Horn = function(path) {
  // The Horn Player.

  var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  var source;
  var buffer;

  var loadSound = function(bufferObj, callback) {
    callback = callback || function() {};

    var xhr = new XMLHttpRequest();

    xhr.onload = function() {
      audioCtx.decodeAudioData(xhr.response, function(decodedBuffer) {
        callback(decodedBuffer);
      });
    };

    xhr.open('GET', path );
    xhr.responseType = 'arraybuffer';
    xhr.send();
  };


  this.start = function(loop, loopStart, loopEnd) {
    source = audioCtx.createBufferSource();

    source.connect(audioCtx.destination);

    source.buffer = buffer;

    source.start(0);
    source.loop = loop;
    source.loopStart = loopStart || 0;
    source.loopEnd = loopEnd || 1;
  };

  this.stop = function() {
    source.stop();
  };

  var init = function() {
    loadSound(buffer, function(decodedBuffer) {
      buffer = decodedBuffer;
    });
  };

  init();
};

// Sync in from localStorage
if (localStorage.nick && localStorage.nick.length > 0) {
  nick.value = localStorage.nick;
}
if (localStorage.history && localStorage.history.length > 0) {
  box.innerHTML = localStorage.history;
  box.scrollTop = box.scrollHeight - 10;
}

// Sounds we can play
var airhorn = new Horn("./sound/airhorn.mp3");
var crickets = new Horn("./sound/crickets.mp3");

// The keys in this dictionary are used as IRC-style commands.
// If a message starts with "/key", then commands["key"] will
// be run.
//  Input:  The object received from pubnub
//  Output: A string containing the HTML to render to the chat window,
//     something falsy if you want the default rendering.
//
// WARNING: Do not send messages from these callbacks, due to
// the risk of cascades.
var commands = {
  // IRC-style /me command
  me: function(obj) {
    var action = obj.message.replace(/^\/me[ ]+/, "");
    return "<i>" + obj.nick + " " + action  + "</i>";
  },

  // Forces all peers to reload the page.  This forces clients
  // to load new code.
  reload: function(obj) {
    window.location.reload();
    return ""; // squelch output
  },

  // Play an airhorn sound
  airhorn: function(obj) {
    var command = obj.message.replace(/^\/airhorn[ ]+/, "");
    switch (command) {
      case "start": airhorn.start(true, 0.24, 0.34); break;
      case "stop": airhorn.stop(); break;
      default: airhorn.start(false); break;
    }
  },

  // Play a cricket sound
  crickets: function(obj) {
    var command = obj.message.replace(/^\/crickets[ ]+/, "");
    switch (command) {
      case "start": crickets.start(true, 0.10, 1.75); break;
      case "stop": crickets.stop(); break;
      default: crickets.start(false); break;
    }
  },
};

// Same as commands, but applied to outbound commands.
//   Input:  The object about to be sent
//   Output: The object to be sent, or something falsy if no
//           object should be sent
var localCommands = {
  flush: function() {
    delete localStorage.history;
    box.innerHTML = "";
  }
};

// Sync in from localStorage
if (localStorage.nick && localStorage.nick.length > 0) {
  nick.value = localStorage.nick;
}
if (localStorage.history && localStorage.history.length > 0) {
  box.innerHTML = localStorage.history;
  box.scrollTop = box.scrollHeight - 10;
}

PUBNUB.subscribe({
  channel: channel,
  callback: function(text) {
    // Special magic command!  For travis to force reload on commit
    // https://ps10.pubnub.com/publish/demo/demo/0/bad-attitude/0/%22DUDE_YOU_SHOULD_TOTES_RELOAD%22
    console.log("received (encrypted): " + text);
    if (text == "DUDE_YOU_SHOULD_TOTES_RELOAD") {
      window.location.reload();
      return;
    }

    decrypt(text).then(function(plaintext) {
      console.log("received (decrypted): " + plaintext);
      var obj = JSON.parse(plaintext);
      obj.nick = clean(obj.nick);
      obj.message = clean(obj.message);

      // If there's a command, let it produce the message
      var display = null;
      for (cmd in commands) {
        if (obj.message.match("^/"+cmd)) {
          display = commands[cmd](obj);
          break;
        }
      }

      // By default, "nick: message"
      if (!display) {
        display = defaultDisplay(obj);
      }

      console.log('display: ' + display);
      box.innerHTML = box.innerHTML + '<br/>' + display;
      box.scrollTop = box.scrollHeight - 10;

      localStorage.history = box.innerHTML;
      box.scrollTop = box.scrollHeight - 10;
    })
    .catch(function(error) {
      console.log("receive/decrypt error: " + error);
    });
;
  }
});

// Sync nick to localStorage
PUBNUB.bind('change', nick, function(e) {
  if (nick.value !== '') {
    nick.style.backgroundColor = '#111';
    localStorage.nick = nick.value;
  }
});

PUBNUB.bind('keyup', message, function(e) {
  if ((e.keyCode || e.charCode) !== 13) {
    return;
  }
  if (nick.value === '') {
    nick.style.backgroundColor = '#a33';
    nick.focus();
    return;
  } else {
    nick.style.backgroundColor = '#111';
  }

  console.log("command: "+ message.value);
  var obj = {
    nick: nick.value,
    message: message.value
  };
  message.value = '';
  for (cmd in localCommands) {
    if (message.value.match("^/"+cmd)) {
      obj = localCommands[cmd](obj);
      break;
    }
  }

  if (!obj) {
    return;
  }

  console.log("sending (decrypted): "+ JSON.stringify(obj));
  encrypt(JSON.stringify(obj))
    .then(function(ciphertext) {
      console.log("sending (encrypted): "+ ciphertext);
      PUBNUB.publish({
        channel: channel,
        message: ciphertext,
      });
    })
    .catch(function(error) {
      console.log("encrypt/send error: " + error);
    });
});

})();
//]]>
</script>
</body>
</html>

<html>

<head>
<title>bad-attitude</title>
<style>

body {
  font-size: 12pt;
  font-family: Monaco, monospace;
  background-color: #111;
}

h1 {
  font-size: 12pt;
  text-align: center;
  color: #0F2;
}

#container {
  max-width: 800px;
  width: 80%;
  margin-left: auto;
  margin-right: auto;
  padding: 1ex;
}

input {
  width: 98.5%;
  font-family: Monaco, monospace;
  padding: 1ex;
  margin-bottom: 1ex;
  margin-top: 1ex;
}

#box {
  width: 95%;
  height:10em;
  overflow:scroll;
  border: 1px solid black;
  background-color: #eee;
  padding: 1ex;
}

</style>
<script>
// Redirect to HTTPS if we need to
(function() {
  if (window.location.href.match("http:")) {
    window.location.href = window.location.href.replace("http:", "https:");
  }
})();
</script>
</head>

<body>

<!-- "Fork me on Github" banner -->
<a href="https://github.com/bad-attitude/bad-attitude.github.io/"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/121cd7cbdc3e4855075ea8b558508b91ac463ac2/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png"></a>

<h1>bad-attitude</h1>

<div id="container">

<input id="nick" placeholder="your-nick-here" /><br/>

<div id="box"></div>

<input id="message" placeholder="your-chat-here" /><br/>

</div>


<script src=https://cdn.pubnub.com/pubnub.min.js></script>
<script>


(function(){
var box = PUBNUB.$('box');
var nick = PUBNUB.$('nick');
var message = PUBNUB.$('message');
var channel = 'bad-attitude';

function clean(text) {
  return (''+text).trim().replace( /[<>]/g, '' );
}

// Generate the key from the URL fragment
// XXX: This might mean that the key won't be ready if we need it,
// but that seems unlikely, and we can detect it.
var key = null;
var CRYPTO = window.crypto.subtle;
var ALGO_HMAC = {name: "HMAC", hash: "SHA-256"};
var ALGO_KEY = "AES-GCM";
var ALGO_ENCRYPT = {
  name: "AES-GCM",
  tagLength: 128,
  iv: new Uint8Array(12)
};
(function() {
  var fragment = window.location.hash.replace("^#", "");
  var fragmentData = new Uint8Array(fragment.length);
  for (var i=0; i<fragmentData.length; ++i) {
    fragmentData[i] = fragment.charCodeAt(i);
  }

  var zeros = new Uint8Array(32);
  for (var i=0; i<zeros.length; ++i) {
    zeros[i] = 0;
  }

  // HKDF(frag) = HMAC(HMAC(0, frag), 0x01)
  CRYPTO.importKey("raw", zeros, ALGO_HMAC, false, ["sign"])
    .then(function(zeroKey) {
      return CRYPTO.sign(ALGO_HMAC, zeroKey, fragmentData);
    })
    .then(function(macData) {
      return CRYPTO.importKey("raw", macData, ALGO_HMAC, false, ["sign"]);
    })
    .then(function(macKey) {
      return CRYPTO.sign(ALGO_HMAC, macKey, new Uint8Array([0x01]));
    })
    .then(function(keyData) {
      return CRYPTO.importKey("raw", keyData, ALGO_KEY, false, ["encrypt", "decrypt"]);
    })
    .then(function(cryptoKey) {
      return key = cryptoKey;
    });
})();

function isCryptoReady() {
  return key != null;
}

// Returns nonce || ciphertext
function encrypt(str) {
  if (!isCryptoReady()) {
    throw "encrypt() call without key available";
    // But you should really call isCryptoReady() yourself
  }

  var plaintext = new Uint8Array(str.length);
  for (var i=0; i<str.length; ++i) {
    plaintext[i] = str.charCodeAt(i);
  }

  window.crypto.getRandomValues(ALGO_ENCRYPT.iv);
  return CRYPTO.encrypt(ALGO_ENCRYPT, key, plaintext)
    .then(function(ciphertext) {
      var output = new Uint8Array(ALGO_ENCRYPT.iv.length + ciphertext.byteLength);
      output.set(ALGO_ENCRYPT.iv, 0);
      output.set(new Uint8Array(ciphertext), ALGO_ENCRYPT.iv.length);
      return window.btoa(String.fromCharCode.apply(null, output));
    });
}

function decrypt(base64) {
  var byteString = atob(base64);
  var nonceAndCiphertext = new Uint8Array(byteString.length);
  for (var i=0; i<byteString.length; ++i) {
    nonceAndCiphertext[i] = byteString.charCodeAt(i);
  }

  ALGO_ENCRYPT.iv.set(nonceAndCiphertext.subarray(0, ALGO_ENCRYPT.iv.length));
  return CRYPTO.decrypt(ALGO_ENCRYPT, key, nonceAndCiphertext.subarray(ALGO_ENCRYPT.iv.length))
    .then(function(plaintext) {
      var plaintextBuffer = new Uint8Array(plaintext);
      var plaintextString = "";
      for (var i=0; i<plaintextBuffer.length; ++i) {
        plaintextString += String.fromCharCode(plaintextBuffer[i]);
      }
      return plaintextString
    });
}

// The keys in this dictionary are used as IRC-style commands.
// If a message starts with "/key", then commands["key"] will
// be run.
//  Input:  The object received from pubnub
//  Output: The html to be added to the chat window
//
// WARNING: Do not send messages from these callbacks, due to
// the risk of cascades.
var commands = {
  // IRC-style /me command
  me: function(obj) {
    var action = obj.message.replace(/^\/me[ ]+/, "");
    return "<i>" + obj.nick + " " + action  + "</i>";
  },

  // Forces all peers to reload the page.  This forces clients
  // to load new code.
  reload: function(obj) {
    window.location.reload();
  },
};

// Same as commands, but applied to outbound commands.
//   Input:  The object about to be sent
//   Output: The object to be sent, or something false if no
//           object should be sent
var localCommands = {
  flush: function() {
    delete localStorage.history;
    box.innerHTML = "";
    return null;
  }
};

// Sync in from localStorage
if (localStorage.nick && localStorage.nick.length > 0) {
  nick.value = localStorage.nick;
}
if (localStorage.history && localStorage.history.length > 0) {
  box.innerHTML = localStorage.history;
  box.scrollTop = box.scrollHeight - 10;
}

PUBNUB.subscribe({
  channel: channel,
  callback: function(text) {
    // Special magic command!  For travis to force reload on commit
    // https://ps10.pubnub.com/publish/demo/demo/0/bad-attitude/0/%22DUDE_YOU_SHOULD_TOTES_RELOAD%22
    console.log("received: " + text);
    if (text == "DUDE_YOU_SHOULD_TOTES_RELOAD") {
      window.location.reload();
      return;
    }

    decrypt(text).then(function(plaintext) {
      try {
        var obj = JSON.parse(plaintext);
        obj.nick = clean(obj.nick);
        obj.message = clean(obj.message);

        // If there's a command, let it produce the message
        var display = "";
        for (cmd in commands) {
          if (obj.message.match("^/"+cmd)) {
            display = commands[cmd](obj);
            break;
          }
        }

        // By default, "nick: message"
        if (display == "") {
          display = '<b>' + obj.nick + '</b>: ' + obj.message;
        }

        box.innerHTML = box.innerHTML + '<br/>' + display;
        box.scrollTop = box.scrollHeight - 10;
      } catch (e) {
        console.log("bad message: "+ JSON.stringify(obj));
        console.log("exception: "+ e);
        box.innerHTML = box.innerHTML + '<br/>Bad message';
      }

      localStorage.history = box.innerHTML;
      box.scrollTop = box.scrollHeight - 10;
    });
  }
});

// Sync nick to localStorage
PUBNUB.bind('change', nick, function(e) {
  if (nick.value !== '') {
    nick.style.backgroundColor = '#fff';
    localStorage.nick = nick.value;
  }
});

PUBNUB.bind('keyup', message, function(e) {
  if ((e.keyCode || e.charCode) !== 13) {
    return;
  }
  if (nick.value === '') {
    nick.style.backgroundColor = '#f33';
    return;
  } else {
    nick.style.backgroundColor = '#fff';
  }

  var obj = {
    nick: nick.value,
    message: message.value
  };
  message.value = '';
  for (cmd in localCommands) {
    if (message.value.match("^/"+cmd)) {
      obj = localCommands[cmd](obj);
      break;
    }
  }

  if (!obj) {
    return;
  }

  console.log("sending: "+ JSON.stringify(obj));
  encrypt(JSON.stringify(obj))
    .then(function(ciphertext) {
      PUBNUB.publish({
        channel: channel,
        message: ciphertext,
      });
    });
});

}());

</script>
</body>
</html>
